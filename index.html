<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport">
    <title>Portfolio de Simulación</title>
    <link rel="stylesheet" href="stylesheet.css">

</head>

<body>
    <header>
        <h1>Simulación</h1>
        <h2>Portfolio</h2>
        <h1>Carlos Marqués García</h1>
    </header>
    <main>
        <section>
            <h2>buble-shooter</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T1/Bubbleshooter.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>buble-shooter sencillo (lanzador de bolas con velocidad constante)</p>
            </div>
        </section>

        <section>
            <h2>Velocidad constante y aceleración entre 2 puntos</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T1/MontañaRusa.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Simular el movimiento de una partícula que se mueve a una velocidad
                    entre dos puntos y vuelve con una aceleración constante
                    debido a la gravedad, como una montaña rusa.</p>
                </p>
                <p>vmedia en un intervalo = ∆x/∆t</p>
                <p>x += vmedia ∗ ∆t.</p>
                <p>velocidad inicial u</p>
                <p>∆t = t − 0; </p>
                <p>a = (v-u)/t</p>
                <p>v = u + a ∗ ∆t</p>
                <p>x = u*t + 1/2 * a*t^2</p>
                </p>

            </div>
        </section>

        <section>
            <h2>Orbitación</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T1/Orbitación.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Simula el movimiento de una bola alrededor de un punto
                    situado a una distancia r de la bola. Da una vuelta por segundo.</p>
                <p> Periodo (T): Tiempo en recorrer una onda completa una función periódica.</p>
                <p> Frecuencia f = 1/T</p>
                <p> Velocidad angular w = 2πf = 2π/T</p>
                <p> w(t) = ∆angulo/∆t</p>

                <p> Posición: </p>
                <p> x = r ∗ cos(w ∗ t), </p>
                <p> y = r ∗ sin(w ∗ t)</p>
            </div>
        </section>

        <section>
            <h2>Osciladores</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T1/PartículaFunción sinusoidalA0.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Este oscilador utiliza una función que devuelve una onda que va disminuyendo la y conforme avanza en
                    la x mediante la función: </p>
                <p> y = sin(x) ∗ exp(−0.002x) </p>
            </div>

            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T1/PartículaFunciónDerivaSinuidal.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Este oscilador utiliza una función que devuelve una onda regida por dos frecuencias diferentes: </p>
                <p> y = 0.5sin(3x) + 0.5sin(3.5x) </p>
            </div>
        </section>
        <section>
            <h2>Tiro parabólico</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T1/Tiro parabólico.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Simula un tiro parabólico (velocidad inicial v, gravedad g y masa m)
                    con el método de Euler.</p>
            </div>
        </section>

        <section>
            <h2>Fuente de Partículas</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T2/FuentePartículas.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Implementación de fuente de partículas en unos ángulos preestablecidos y aplicándoles un peso para
                    que caigan.</p>
            </div>
        </section>

        <section>
            <h2>Partícula flotante</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="T2/HieloFlotando.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Simula una partícula flotando en un líquido con densidad ρ y gravedad g, teniendo en cuenta el
                    volumen sumergido de la partícula</p>
                <p>Estabilidad: Centro de gravedad/masas y de flotación.</p>
                <p>Fuerza de flotación: FB = ρ*g*Vs</p>
                <p>ρ = densidad</p>
                <p>Vs = Vol.sumergido</p>
                <p>Vs−totalmente−sumergido = 4 ∗ PI ∗ radius ∗ radius ∗ radius/3</p>
                <p>Parcialmente sumergido:</p>
                <p>h = location.y + radius - height/2;</p>
                <p>a = sqrt (2 * h * radius - h * h);</p>
                <p>Vs = (3 * a*a + h*h) * PI * h / 6;</p>

            </div>
        </section>

        <section>
            <h2>Simulación física de una partícula colgando de otra fija</h2>
            <div class="video-text-container">
                <p> Simulación física de una partícula colgando de otra fija, para ello se calcula la fuerza de
                    elasticidad</p>
                <p> //L-L0
                <p> float elongation = PVector.dist(_pos2, _pos1) - _l0; </p>
                <p> PVector direction = PVector.sub(_pos2, _pos1).normalize();</p>

                <p> FE = Ke*elongation;</p>

                <p> F = direction.mult(FE);</p>

                <p> además se le aplica rozamiento y gravedad.</p>
                <p>Debido al costo de calcular a cada momento esto, hay diferentes métodos para en un lapso de tiempo
                    especificado (timestep) aproximar el cálculo.</p>

                <figure>
                    <video width="560" height="320" controls>
                        <source src="P1/EulerExplícito.mp4" type="video/mp4">
                    </video>
                </figure>
                <p> _a = calculateAcceleration(_s, _v);</p>
                <p> s(t+h) = s(t) + h*v(t)</p>
                <p> v(t+h) = v(t) + h*a(s(t),v(t))</p>
            </div>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P1/EulerSimpléctico.mp4" type="video/mp4">
                    </video>
                </figure>
                <p> _a = calculateAcceleration(_s, _v);</p>
                <p> v(t+h) = v(t) + h*a(s(t),v(t))</p>
                <p> s(t+h) = s(t) + h*v(t)</p>
            </div>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P1/Heun.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>_a = calculateAcceleration(_s, _v);</p>

                <p> Calculo de la velocidad en el punto medio</p>
                <p> PVector v12 = PVector.add(_v, PVector.mult(_a, _timeStep * 0.5));</p>

                <p> Calculo de la posicion en el punto medio</p>
                <p> PVector s12 = PVector.add(_s, PVector.mult(_v, _timeStep * 0.5));</p>

                <p> Calculo de la aceleracion en el punto medio</p>
                <p> PVector a12 = calculateAcceleration(s12, v12);</p>

                <p> Actualizamos la velocidad y la posicion</p>
                <p> _v.add(PVector.mult(a12, _timeStep));</p>
                <p> _s.add(PVector.mult(v12, _timeStep));</p>
            </div>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P1/RK2.mp4" type="video/mp4">
                    </video>
                </figure>
                <p> _a = calculateAcceleration(_s, _v);</p>

                <p> Primer paso (k1)</p>
                <p> k1v = h * a(s, v)</p>
                <p> k1s = h * v</p>

                <p> Segundo paso (k2)</p>
                <p> k2v = h*a(s + k1s/2, v + k1v/2)</p>
                <p> k2s = h*(v + k1v/2)</p>

                <p> Actualización de la velocidad y la posición</p>
                <p> v(t+h) = v(t) + k2v</p>
                <p> s(t+h) = s(t) + k2s</p>
            </div>

            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P1/RK4.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>_a = calculateAcceleration(_s, _v);</p>

                <p> Primer paso (k1)</p>
                <p> k1v = h * a(s, v)</p>
                <p> k1s = h * v</p>

                <p> Segundo paso (k2)</p>
                <p> k2v = h*a(s + k1s/2, v + k1v/2)</p>
                <p> k2s = h*(v + k1v/2)</p>


                <p> Tercer paso (k3)</p>
                <p> k3v = h*a(s + k2s/2, v + k2v/2)</p>
                <p> k3s = h*(v + k2v/2)</p>


                <p> Cuarto paso (k4)</p>
                <p> k4v = h*a(s + k3s, v + k3v)</p>
                <p> k4s = h*(v + k3v)</p>

                <p> Actualización de la velocidad y posición</p>
                <p> v(t+h) = v(t) + 1/6 * (k1v + 2*k2v + 2*k3v + k4v)</p>
                <p> s(t+h) = s(t) + 1/6 * (k1s + 2*k2s + 2*k3s + k4s)</p>
            </div>
        </section>
        <section>
            <h2>Simulación de humo</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="Humo.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Se crea humo gracias a partículas con textura que se generan con velocidades con direcciones dentro
                    de un rango que son afectadas por la gravedad, y el viento.</p>
            </div>
        </section>
        <section>
            <h2>Simulación de un billar</h2>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P3/Colisión.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>Calculando velocidades en cada lapso de tiempo establecido (timestep) se crea un sistema de
                    colisiones plano-partícula y partícula-partícula, que hacen posible la creación de un billar.</p>
            </div>
        </section>
        <section>
            <h2>Optimización de la detección de colisiones</h2>
            <div class="video-text-container">
                <p>Debido al alto coste de calcular la posible interacción entre todas las partículas, que impediría la
                    escalabilidad del sistema de colisiones, existen diferentes métodos que lo optimizan:</p>
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P3/GRID.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>El coste de la colisión de partículas cuando se usa grid es muchísimo menor O(log(N)), pues al estar
                    subdividida </p>
                <p> la pantalla en celdas, cada partícula solo es evaluada respecto a las partículas de las celdas
                    vecinas, obtenidas</p>
                <p> al recorrer la matriz de celdas, siendo así muchísimo menor el número de partículas con las que se
                    debe evaluar la posible colisión.</p>
            </div>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P3/HASH.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>El coste computacional cuando se usa hash es aún menor, con una complejidad similar a la del grid.
                </p>
                <p> Además de la subdivisión de la pantalla, la función de hash asigna directamente cada partícula a una
                </p>
                <p> celda específica conocida, lo que agiliza la obtención de las celdas vecinas, resultando en un coste
                </p>
                <p> computacional más bajo con la configuración correcta de tamaño de celda y tamaño de tabla hash.
                </p>
            </div>
        </section>
        <section>
            <h2>Portería con malla deformable y destruible</h2>
            <div class="video-text-container">
                <p>Se observa el comportamiento de una pelota de futbol que impacta con una fuerza sobre una malla cuya
                    deformación/desgarro está regida por tres disposiciones de muelles mezcladas structural, shear, bend
                </p>
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P4/DeformarMalla.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>La malla se deforma</p>
            </div>
            <div class="video-text-container">
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P4/DestrucciónMalla.mp4" type="video/mp4">
                    </video>
                </figure>
                <p>La malla se desgarra al recibir una fuerza mayor a la que soporta</p>
            </div>
        </section>
        <section>
            <h2>Malla deformada por mapa de alturas</h2>
            <div class="video-text-container">
                <p>Deformación de malla mediante el posicionamiento de los vértices de esta a una altura determinada por
                    el mapa de alturas, </p>
                <p> este es modificado según diferentes funciones de ondas lineales, radiales y Gerstner para simular
                    diferentes tipos de oleajes y goteos</p>
                    <p> Esas funciones además están regidas por amplitudes, longitudes de onda y velocidades preestablecidas</p>
                    <p></p><p></p><p></p><p></p>
            <div class="video-text-container">
                <p>Simulación de gotas de agua caen y generan una pequeña onda radial</p>
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P4/gotas.mp4" type="video/mp4">
                    </video>
                </figure>
            </div>
            <div class="video-text-container">
                <p>Simulación un mar agitado</p>
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P4/marintranquilo.mp4" type="video/mp4">
                    </video>
                </figure>
            </div>
            <div class="video-text-container">
                <p>Simulación de un mar tranquilo</p>
                <figure>
                    <video width="560" height="320" controls>
                        <source src="P4/martranquilo.mp4" type="video/mp4">
                    </video>
                </figure>
            </div>
            <p>Amplitud modificada</p>
            <figure>
                <video width="560" height="320" controls>
                    <source src="P4/amplitud.mp4" type="video/mp4">
                </video>
            </figure>
        </div>
        <div class="video-text-container">
            <p>Longitud de onda modificada</p>
            <figure>
                <video width="560" height="320" controls>
                    <source src="P4/longitudonda.mp4" type="video/mp4">
                </video>
            </figure>
        </div>
        <div class="video-text-container">
            <p>Velocidad modificada</p>
            <figure>    
                <video width="560" height="320" controls>
                    <source src="P4/velocidad.mp4" type="video/mp4">
                </video>
            </figure>
        </div>
        </section>
    </main>
    <footer>Copyright &copy; 2024</footer>
</body>

</html>
